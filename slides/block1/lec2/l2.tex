\input{../../common/slide-common-header.tex}
\input{../../common/slide-plan.tex}

\title[]{Lecture \basicNum: \basicTopic}
\subtitle[]{\basicKey}
\author[]{Alexander Filatov\\ filatovaur@gmail.com}

\date{}

\newcommand{\taskAsyncException}{2.1}
\newcommand{\taskProofMutex}{2.2.a}
\newcommand{\taskProofDeadlockFreedom}{2.2.b}
\newcommand{\taskReentrant}{2.3}
\newcommand{\taskCounters}{2.4}
\newcommand{\taskEmpireLock}{2.5}
\newcommand{\taskCodeDining}{2.6}

\begin{document}

\begin{frame}
  \titlepage
    \url{https://github.com/Svazars/parallel-programming/blob/main/slides/pdf/l2.pdf}
\end{frame}

\begin{frame}{In previous episode}

\begin{itemize}
 \item We study communication and coordination of different agents.
 \item Every agent has its own speed and scenario of execution.
 \item We are focusing on threads which are part of OS process and managed by scheduler.
 \item We expect OS to use pre-emptive multitasking (time-sharing of CPU cores).
 \item Interleaving \texttt{N:1} is useful yet simplified model of concurrent execution.
\end{itemize}

Any concurrent task has
\begin{itemize}
    \item parallel (independent) and sequential (dependent)
\end{itemize}
parts so max speedup is limited by Amdahl's law.

Threads have read/write access to shared memory which leads to
\begin{itemize}
    \item non-determinism, race conditions, data races, visibility problems
\end{itemize}

Threads use blocking methods which leads to
\begin{itemize}
    \item deadlocks, priority inversion
\end{itemize}
therefore we use wait-for graphs and observability API.

\end{frame}

\begin{frame}{Lecture plan}
\tableofcontents
\end{frame}

\input{parts/thread_safety.tex}
\input{parts/mutual.tex}
\input{parts/mutex.tex}
\input{parts/visibility.tex}

\begin{frame}{Mutual exclusion}
\framesubtitle{Conclusion}

\begin{itemize}
    \item Mutual exclusion maintains ''order of execution'' for code fragment, one thread a time
    \item Implicit control flow (e.g. exceptions) may violate consistency of concurrent primitive
    \item Performance depends on OS (scheduling quantum, scheduling policy, context switch overheads, priority) and particular implementation (admission policy)
    \item There are different flavours of locking primitives (reentrancy, fairness)
\end{itemize}

Locks help to solve some problems:
\begin{itemize}
    \item avoid data race
    \item prevent race condition
    \item implement thread-safety
\end{itemize}
but may introduce new challenges:
\begin{itemize}
    \item deadlock
    \item starvation/unfairness
    \item sequential part of execution (see Amdahl's law in Lecture~\introNum)
\end{itemize}
\end{frame}

\input{parts/patterns.tex}
\input{parts/prevention.tex}
%%%\input{parts/signalling.tex}

\section{Summary}

\begin{frame}{Summary}

\begin{itemize}
    \item Mutual exclusion helps to achieve thread-safety
    \item \texttt{Mutex} (\texttt{lock}, \texttt{critical section}) provides easy-to-use and simple API. Key concepts:
    \begin{itemize}
        \item deadlock-freedom, starvation-freedom, reentrancy, admission policy, fairness
    \end{itemize} 

    \item There are different ways to structure concurrent programs with locks:
    \begin{itemize}
        \item code locking, data locking, lock splitting
    \end{itemize}

    \item Mutex is a blocking primitive, so be aware of possible deadlocks:
    \begin{itemize}
        \item recursive locks, encapsulation, enforcing lock acquisition order, avoiding external code invocation inside critical section
    \end{itemize}

    \item Documenting locking policy is a key to modular and reliable concurrent software
    \item Do not forget to read documentation of thread-safe classes you use
\end{itemize}

\end{frame}


%\begin{frame}{Summary}
%
%Some data races and race conditions could be avoided by mutual exclusion.
%
%\texttt{Mutex} (a.k.a. \texttt{lock}, a.k.a. \texttt{critical section}) provides easy-to-use and simple API.
%
%Do not forget to keep an eye on
%\begin{itemize}
%    \item safety/correctness, liveness/progress guarantees, visibility/consistency, performance
%\end{itemize}
%
%Use suitable locking policies for your use-cases
%\begin{itemize}
%    \item code locking, data locking, lock splitting
%\end{itemize}
%
%Remember to document locking policy to keep your program modular/reusable.
%
%Do not forget to read documentation of thread-safe classes you use.
%
%Condition variable allows to replace polling with OS-level signalling.
%
%Signalling protocols must be aware of
%\begin{itemize}
%    \item lost signals, predicate invalidation, spurious wakeups, fairness
%\end{itemize}
%\end{frame}

\begin{frame}{Summary: homework}

\texttt{Lecture 2, Tasks 2.*:} {\tiny\url{https://github.com/Svazars/parallel-programming/blob/main/hw/block1}}

\end{frame}


%Big homework (4w)
    %bounded thread pool, blocking awaits are self-helping,
%- design
%- tests
%- deadlock conditions
%- example of deadlock with resource-constrained cause


% \begin{frame}{Producer consumer}
% Unbounded queue with mutex
% \end{frame}
% 
% \begin{frame}{Publisher-subsrciber}
% Pull/push approaches, reactive systems
% \end{frame}
% 
% \begin{frame}{Backoff policies}
% Livelock
% \end{frame}
% 
% \begin{frame}{Problems}
% 
% message passing + backpressure 
% self impl thread-safe counter
% self impl striped lock (hashmap?)
% \end{frame}


\end{document}
